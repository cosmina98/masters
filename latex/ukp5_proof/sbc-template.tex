\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{fixltx2e}
\usepackage{enumerate}

\usepackage[utf8]{inputenc}  
 
\usepackage{algorithm}
\usepackage{algpseudocode}

\sloppy

\title{The UKP5 Method}

\author{Henrique Becker\inst{1}}

%\address{Instituto de Ciências Exatas e Geociências -- Universidade Passo Fundo (UPF)\\
%  Caixa Postal 611 -- CEP 99001-970 -- Passo Fundo -- RS -- Brasil
\address{Instituto de Informática -- Universidade Federal do Rio Grande do Sul (UFRGS) \\
  Caixa Postal 15064 -- CEP 91501-970 -- Porto Alegre -- RS -- Brasil
  \email{henriquebecker91@gmail.com}
}

\begin{document} 

\maketitle

\section{Introduction}

The objective of this work is to present an algorithm that solves the Unbounded Knapsack Problem (UKP), and to prove its correctness. We name this algorithm UKP5.

\subsection{Definition of the Problem and Chosen Notation}

In this subsection we use the chosen notation to define the UKP. We will use this notation for the rest of the article.

The UKP can be defined as follows: we are given a capacity \(c\), and a list of \(n\) items. Each item \(i \in {1, \ldots, n}\) has a weight value, denoted by \(w_i\), and a profit value, denoted by \(p_i\); we want to know how many of each item (\(x_i\)) we should select to get the biggest possible items profit sum without the items weight sum becoming bigger than the capacity. The problem can be defined using the linear programming notation as follows:

\begin{align}
  maximize: &\sum_{i=1}^n p_i x_i\label{eq:objfun}\\
subject~to: &\sum_{i=1}^n w_i x_i \leq c\label{eq:capcons}\\
            &x_i \in \mathbb{N}_0\label{eq:x_integer}
\end{align}

The capacity \(c\), the quantity \(n\) and the weights of the items \(w_i~(\forall i.~1 \geq i \geq n)\) are all positive integers. The quantities \(x_i~(\forall i.~1 \geq i \geq n)\) are restricted to the non-negative integers, as shown in \eqref{eq:x_integer}. The profit of the items \(p_i~(\forall i.~1 \geq i \geq n)\) are all positive real numbers.

The efficiency of an item \(i\) is the value of \(\frac{p_i}{w_i}\). We will refer to the efficiency of an item as \(e_i\). The UKP5 works faster when the items are ordered by non-decreasing efficiency (i.e. \(i < j\) iff \(\frac{p_i}{w_i} < \frac{p_j}{w_j}\), or simply \(i < j\) iff \(e_i < e_j\) (if two or more items have the same efficiency, we order them by non-decreasing weight). If the items aren't ordered the UKP5 order them first.

We use \(w_{min}\) and \(w_{max}\) to denote the smallest item weight and the biggest item weight, respectively.

\subsection{Some extra definitions}

A solution for an arbitrary UKP instance is a multiset of the items defined by that instance. The weight of a solution is the solution items weight sum. The profit of a solution is analogue. A valid solution for an arbitrary UKP instance is a solution where the solution weight is less or equal than the capacity established by the instance. The empty multiset is a trivial valid solution for any UKP instance. An optimal solution of an arbitrary UKP instance is a valid solution with the biggest profit between all valid solutions of that instance. The optimal solution value of an arbitrary UKP instance is that instance optimal solution profit. We say that one solution \(s\) dominates another solution \(t\) in a UKP instance iff both are valid for that instance and \(w_s \leq w_t \land p_s \geq p_t\). All the four dominance relations presented in (CITE OTHER ARTICLES) are special cases of one solution being dominated by other (i.e. dominating other).

\section{First Theorem: Dominance and optimal solutions}

If one solution is dominated by other, both can be subsets of optimal solutions\footnote{For example, see the following UKP instance: \(c = 10,~w_1 = 9,~w_2 = 10,~p_1 = p_2 = 10\); the solutions made from one item \(1\) or one item \(2\) are both optimal solutions. Other example: \(c = 12,~w_1 = 9,~w_2 = 10,~w_3 = 2,~p_1 = p_2 = 10, p3 = 1\).}. However, we can can assert that: if a solution \(s\) is dominated by a solution \(t\), and \(s\) is a subset of an optimal solution, then \(t\) is also a subset of an optimal solution.

The proof is simple: lets suppose \(opt\) is an optimal solution, \(s \cup s' = opt\) and \(s\) is dominated by \(t\); lets define \(opt' = t \cup s'\); \(opt'\) will have a no lower profit and a no greater weight than \(opt\); \(opt'\) is a valid solution because its weight is less than or equal to another valid solution (\(opt\)); we have the guarantee that \(p_{opt'} \geq p_{opt}\) but also, as \(opt\) is an optimal solution, we have the guarantee that no valid solution has a greater profit than it, therefore \(p_{opt'} = p_{opt}\); by definition \(opt'\) is an optimal solution (there's no valid solution with greater profit); finally \(t \cup s' = opt' \implies t \subseteq opt')\), this way we prove that in this conditions \(t\) must be a subset of an optimal solution. If \(s' = \varnothing\) then both \(s\) and \(t\) are optimal solutions.

\section{The proof of correctness and explanation of the algorithm}

An UKP5 algorithm correctness proof constructed directly over the algorithm optimized final code would be, in our opinion, hard to understand. We chose to follow a different path, and we will instead show a correctness proof for an initial version of the algorithm, and for each of the four subsequent algorithm optimizations we will show proof that despite of the change the code stands correct. We think that is more important that a proof is clear than that it use less pages. This approach also has the beneficial side-effect of providing insight over the big performance difference that one or two lines of the algorithm code account for.

\section{UKP0 -- The classic dynamic programming approach}

\section{UKP1 -- A quasi-exhaustive approach}

\begin{algorithm}
\caption{UKP One}\label{alg:ukp1}
\begin{algorithmic}[1]
\Procedure{UKP1}{$n, c, w, p, w_{min}, w_{max}$}
  \State \(g \gets\) array of \(c + 1 + (w_{max} - w_{min})\) positions each one initialized with \(0\)\label{ukp1:create_g}
  \State % Blank line
  \For{\(i \gets 1,~n\)}\label{begin_trivial_bounds}
    \If{\(g[w_i] < p_i\)}
      \State \(g[w_i] \gets p_i\)
    \EndIf
  \EndFor\label{end_trivial_bounds}
  \State % Blank line
  \For{\(y \gets w_{min},~c-w_{min}\)}\label{ukp1:main_ext_loop_begin}
    \If{\(g[y] == 0\)}\label{ukp1:if_equal_to_zero}
    	\State \textbf{continue}
    \EndIf\label{ukp1:if_equal_to_zero}
    \State % Blank line
    \For{\(i \gets 1,~n\)}\label{ukp1:main_inner_loop_begin}
      \If{\(g[y + w_i] < g[y] + p_i\)}\label{ukp1:if_better_solution_begin}
        \State \(g[y + w_i] \gets g[y] + p_i\)
      \EndIf\label{ukp1:if_better_solution_end}
    \EndFor\label{ukp1:main_inner_loop_end}
  \EndFor\label{ukp1:main_ext_loop_end}
  \State % Blank line
  \State \(opt \gets 0\)
  \For{\(y \gets c-w_{min}+1,~c\)}\label{ukp1:opt_loop_begin}
    \If{\(g[y] > opt\)}\label{ukp1:opt_loop_if}
      \State \(opt \gets g[y]\)
    \EndIf
  \EndFor\label{get_y_opt_loop_end}
\EndProcedure
\end{algorithmic}
\end{algorithm}

The UKP1 is an algorithm for computing the UKP optimal solution value. By that, we mean that the \(opt\) variable will have the optimal solution value by the end of the algorithm execution. The proof of its correctness is broken in the three theorems bellow.

We will refer to the set of the valid solutions for an arbitrary UKP instance as \(V\), and the set of the items provided by the instance as \(I\). As we never mix items or solutions of two different instances this sintax isn't ambiguous. Also, we define \textit{profit dominance} as the dominance special case where the weight of two solutions is equal, but the profit can be distinct (i.e. \(s\) is profit dominated by \(t\) iff \(w_s = w_t \land p_s \leq p_t\)). For an UKP instance of capacity \(c\) there's a maximum of \(c+1\) non profit dominated instances\footnote{For an example, for any capacity \(c\), an instance that have an element with weight \(1\) will have \(c+1\) non profit dominated solutions (the empty solution and the solutions with \(k\)-times that one element, \(1 \leq k \leq c\)).}). These definitions will help us in the proof bellow.

The main point of the proof is that UKP1 stores in \(g\) all valid solutions, except by the ones that are profit dominated by others. As we already saw, in (CITE DOMINANCE THEOREM), if a dominated solution would be part of an optimal solution, the dominator solution would too be part of an optimal solution. This way, we have no reason to store both dominated and dominator, and we can only store dominator solutions. As this excludes only dominated solutions, this cannot exclude all optimal solutions. Therefore the biggest profit value stored in \(g\) is by definition the optimal solution value.

\subsection{UKP1 First Theorem: All relevant solutions are generated}

%We define this theorem more accurately as: after the line~\ref{ukp1:main_ext_loop_end} of UKP1, each position \(y\) of the array \(g\) between \(w_min\) and \(c\) has biggest profit of a solution with weight exactly \(y\), or the value zero, if there's no solution that weights exactly \(y\). In mathematical notation:
%\begin{flalign}
%\forall (y \in [w_{min},c]).~\forall (s \in V ).~\exists (t \in V).&&\nonumber\\
%(g[y] > 0 \land w_s = y)& \iff ((w_t = y) \land (g[y] = p_t) \land (p_t \geq p_s))
%\end{flalign}
%\begin{flalign}
%\forall (y \in [w_{min},c]).~(g[y] = 0) \iff (\nexists (s \in V). (w_s = y))&&
%\end{flalign}

We define this theorem as: After the execution of UKP1 line~\ref{ukp1:main_ext_loop_end}, the profit value of every non profit dominated valid solution can be found between positions \(0\) and \(c\) of array \(g\). We prove this theorem by induction.

\subsubsection{Base case: Empty solution}

The empty solution is present, as \(g[0] = 0\) since line \ref{ukp1:create_g}, and is not modified until \ref{ukp1:main_ext_loop_end}.

\subsubsection{Base case: One single item solution}

The UKP1 first loop (lines~\ref{begin_trivial_bounds}~to~\ref{end_trivial_bounds}) iterates all items and store its profits at \(g[w_i]\). If two or more items have the same weight only the greatest profit is stored. Every non profit dominated solution made up of only one item is therefore present. The second loop (lines~\ref{ukp1:main_ext_loop_begin}~to~\ref{ukp1:main_ext_loop_end}) can change that, but only by replacing a one item solution by a multiple item solution that profit dominates it. As that one item solution was profit dominated, our theorem stands correct.

\subsubsection{Induction Hypothesis: \(s\) solutions}

Assume that, for every valid non profit dominated solution \(s\), the profit value of \(s\) is stored in \(g[w_s]\).

\subsubsection{Step case: \(s \cup \{i\}\) solutions}

Lets define the \(s'\) solution as \(\forall s \in V.~\forall i \in I.~(|s| > 0) \implies (s' = s \cup \{i\})\). From this definition we can derive that \(w_{s'} > w_s\) (all item weights are positive). So \(g[w_s]\) is found by the UKP1 second loop (lines~\ref{ukp1:main_ext_loop_begin}~to~\ref{ukp1:main_ext_loop_end}) before \(g[w_s']\). We guarantee that the position \(g[w_s]\) will not be skipped by the if statement at line~\ref{ukp1:if_equal_to_zero} because, for any nonempty solution \(s\), \(p_s > 0\) and \(g[w_s] = p_s\). Then the UKP1 inner loop (lines~\ref{ukp1:main_inner_loop_begin}~to~\ref{ukp1:main_inner_loop_end}) will combine \(s\) with every item making every possible \(s'\) out of it. If there was already a solution with weight \(w_{s'}\), and \(s'\) profit dominates that solution, then \(g[w_s']\) is updated.

This way, when the outer loop iteration with \(y = w_{s'}-w_{min}\) ends, UKP1 will have computed all the non profit dominated solutions with weight lesser than or equal to \(w_{s'}\). The final value of \(y\) is \(c-w_{min}\) so, after the last iteration of the outer loop, we will have stored in \(g\) all the non profit dominated solutions with weight lesser than or equal to \(c\) (i.e. all the valid non profit dominated solutions).

Observe that \(s'\) can be an invalid solution (\(w_{s'} > c\)). That is not relevant because our theorem is restricted to the \(g\) positions between \(0\) and \(c\).

\subsection{UKP1 Second Theorem: An optimal solution is present in \(g\)}

\subsection{UKP1 Third Theorem: If there's an optimal solution in \(g\), \(opt\) value is equal to it}

\section{UKP2 -- Reducing the optimal solution value search range}
Adding the last for loop:
	* As we prove that the optimal solution has to be somewhere between \((c-w_min)+1\) and \(c\) (both limits included), we give a pass by that range and end up with the optimal solution profit value.

\section{UKP3 -- Pruning symmetry -- Only one way to reach each solution}
The algorithm with the d array change:
	* We prove that any solution generated the initial algorithm is yet generated, we only eliminated the many distinct ways to reach that solution.

\section{UKP4 -- Discarding solutions that can't lead to the optimal solution}
The algorithm with the if change:
	* We do not generate all solutions anymore. Before this change we were generating solutions worse than others already created. We prove that when we discard an solution, if it would lead to an optimal solution, then we already have a solution that will to lead to the optimal solution.

\section{UKP5 -- Knowing when to stop}
The algorithm with the periodic check change:
	* We prove that if a condition defined by us is met, we can stop the computation and calculate the optimal solution value from a simple formula in O(1) time.

\end{document} 

\bibliographystyle{sbc.bst}
\bibliography{sbc-template.bib}

\end{document}

