Six pages. 1986. Authors: Harold GREENBERG
PDF of decent quality.

Greenberg introduce two methods for solving the unbounded knapsack problem on this paper (both methods find optimal value and item multiset that is the solution). As the paper "A Better Step-off Algorithm for the Knapsack Problem", the algorithms are described as a set of steps, where each step point which will be the next step (completely 'goto' oriented). The definition of the algorithms is precise (the algorithms are described step-by-step), but the real understanding of how they work is buried under 'proofs' that use heavy and old mathematical notation.

Both algorithms seems to have been created by Greenberg to toy around with some concepts and general programming ideias that were novel on the time the paper was written. The objective wasn't to make the most efficient algorithm, but to explore such concepts over a very simple problem (the UKP).

The first algorithm is exact, uses only integer arithmetic, and always find the solution. The ideia of the algorithm is to aggregate the capacity constraint and the objective (sum of the profits) on one equation. Instead of working over weights and profits, we work over numbers that aggregate both. The items are remade this way: the weight is multiplied by the upper bound + 1 and summed to the profit. The generated solutions are simple the sum of those item-numbers. As the sum of the profits will never become so big as the upper bound + 1 you can get the weight with 'solution-number / upper bound + 1' (the integer division) and the profit with 'solution-number % upper bound + 1' (the '%' is the modulo operator). A fully functional and commented version of the algorithm is available at https://github.com/henriquebecker91/masters/blob/e2beb54b579a84d291e0a47a6a993becd02d2c3a/codes/cpp/greendp.hpp (search for mgreendp1).

The second algorithm is exact, needs to use real numbers on some points (and can compare them to equality after, so precision is a must), and can fail to find a solution (don't work for all instances). The ideia of this algorithm is a little more complex. The algorithms removes the best item (the most efficient item) from the items list, and compute many solutions with this restricted list. The solutions are generated until the algorithm finds the most efficient solution for each value of x (range 1..'best item profit - 1'). The solution profit value can be exactly 'x' or be 'x + k*best_item_profit' for any k > 1 (integer). For example, if the best item profit is 100, 99 most efficient solutions are searched, one of those solutions have profit value modulo 100 equal to 1, other have it equal to 2, and so on, until 99; the solution can have profit 1, or 10001 (1 + k*100), but only one solution of the ones with residue 1 will be saved, and one with residue 2 (that can be 102, for example) and so on. After this, we can subtract the profit of those solutions from the upper bound and fill the remaining profit with copies of the best item. This technique can fail if some of those "most efficient solutions without the best item" weight more than the capacity (i.e. are invalid). This can happen because the combination of copies of the best item with those most efficient solutions is guaranteed to find the optimal solution only if those solutions really are the most efficient ones for their residue; and the most efficient solution for the residue x (ex: 5) have profit value z (ex.: 10005), but z can't be reached without making a solution that is bigger than the knapsack capacity. A fully functional and documented version of this algorithm can be found at https://github.com/henriquebecker91/masters/blob/e2beb54b579a84d291e0a47a6a993becd02d2c3a/codes/cpp/greendp.hpp (search for mgreendp2).

IT'S VERY IMPORTANT TO NOTE THAT GREENBERG FORGOT TO INCLUDE ONE LINE ON BOTH ALGORITHMS: on step 2d of the algorithm 1 the assignment "D(z) = k" should be executed together with the other assignments, and on step 2d of algorithm 2 the assignment "D(x) = k" should be executed together with the other assignments. If this isn't done, the algorithm can't backtrack the solution after finding the optimal solution value.

